package gopcd

import (
	"bytes"
	"errors"
	"image"
	"image/color"
	"io"
	"log"
	"os"
	"unsafe"
)

//////////////////////////////////////////////////////////////
//
// Overall PCD file structure
// (in sector measures)
//
//////////////////////////////////////////////////////////////
//
// Name				Start			Length
// IP-ICA			0				1
// IPA				1				2
// Base/16 ICA		3				1
// Base/16 ICD		4				18
// Base/4 ICA		22				1
// Base/4 ICD		23				72
// Base ICA			95				1
// Base ICD			96				288
// 4Base ICA		384				1
// 4Base LPT-MRS	385				2
// 4Base LPT		387				1
// 4Base HCT		388				1
// 4Base ICD		389				variable
// 16Base ICA		var				1				// Start defined by the base4Stop field in the
// ImageComponentAttributes
// 16Base LPT-MRS	var				9
// 16Base LPT		var				2
// 16Base HCT		var				2
// 16Base ICD		var				variable
//
// ICA - Image Component Attributes
// IPA - Image Pack Attributes
// ICI - Image Component Information
// ICD - Image Component Data (luma and interleaved chroma)
// LPT - Line Pointer Table
// HCT - Huffman Code Table

type ipiHeader struct {
	ipiSignature                [7]byte // "PCD_IPI"
	specificationVersion        [2]byte // Binary coded MSB major, LSB minor
	authoringSoftwareRelease    [2]byte // Binary coded MSB major, LSB minor
	imageMagnificationDecriptor [2]byte // BCD coded MSB major, LSB minor
	imageScanningTime           [4]byte // Binary coded seconds since 1970-01-01 GMT
	imageModificationTime       [4]byte // Binary coded seconds since 1970-01-01 GMT

	imageMedium byte
	// 0 - color negative
	// 1 - color reversal
	// 2 - color hard copy
	// 3 - thermal hard copy
	// 4 - black and white negative
	// 5 - black and white reversal
	// 6 - black and white hard copy
	// 7 - internegative
	// 8 - synthetic image

	productType              [20]byte // Product code, ISO 646, etc blank padded
	scannerVendorIdentity    [20]byte // Vendor ID, ISO 646, etc blank padded
	scannerProductIdentity   [16]byte // Scanner ID, ISO 646, etc blank padded
	scannerFirmwareRevision  [4]byte  // ISO 646, etc blank padded
	scannerFirmwareDate      [8]byte  // ISO 646, etc blank padded
	scannerSerialNumber      [20]byte // ISO 646, etc blank padded
	scannerPixelSize         [2]byte  // BCD coded in microns, LSB is after the decimal
	piwEquipmentManufacturer [20]byte // Imaging workstation manufacturer, ISO 646, etc blank padded

	photoFinisherCharSet byte
	// 1 - 38 characters ISO 646
	// 2 - 65 characters ISO 646
	// 3 - 95 characters ISO 646
	// 4 - 191 characters ISO 8859-1
	// 5 - ISO 2022
	// 6 - includes characters not ISO 2375 registered
	photoFinisherEscapeSequence [32]byte // Used for set 5 and 6, conforms to ISO 2022 excluding esc
	// unused chars 00
	photoFinisherName [60]byte // per previous two fields
	sbaSignature      [3]byte  // "SBA" - rest of the sba fields exist only if this is defined
	sbaRevision       [2]byte  // Binary coded MSB major, LSB minor

	sbaCommand byte
	// 0 - neutral SBA on, color SBA on
	// 1 - neutral SBA off, color SBA off
	// 2 - neutral SBA on, color SBA off
	// 3 - neutral SBA off, color SBA on

	sbaData         [94]byte   // Proprietary Kodak data
	sbaFTN          [2]byte    // FTN code
	sbaData2        [4]byte    // Proprietary Kodak data
	copyrightStatus byte       // 1 - restrictions apply, 0xff - restrictions not specified. If restrictions apply, see next field
	copyrightFile   [12]byte   // Filename of the rights file in the "RIGHTS" directory on the CD
	reservedBytes   [1192]byte // Used fill to 1536
}

type imageComponentAttributes struct {
	reserved   [2]byte
	attributes byte
	// Bit 7 unused
	// Bit 6-5 : Huffman code class
	// Bit 4 : IPE present (should always be 0)
	// Bit 3-2 : 00 - Base, 01 - 4Base, 10 - 16Base
	// Bit 0-1 : Rotation 00 - 0deg, 01 - 90CCW, 10 - 180CCW, 11 - 270CCW

	sectorStop4Base           [2]byte // Sector end of the 4 base data
	sectorStop16Base          [2]byte // Sector end of the 16 base data
	sectorStopIPE             [2]byte // Should be 0 as IPE is unimplemented
	interleaveRatio           byte    // Should be 1 for photo CD images only if anything else, we have audio data interleaved.
	ADPCMResolution           byte
	ADPCMMagnificationPanning [2]byte
	ADPCMMagnifacationFactor  byte
	ADPCMDisplayOffset        [2]byte
	ADPCMTransitionDescriptor byte
	reserved2                 [495]byte // Fill to 512 bytes
}

// The ICI for each image (scene) is identical to the base16 image, IF the scene exists.
type fileHeader struct {
	signature [7]byte    // PCD_OPA is overview file
	reserved  [2041]byte // Fill to sector size

	ipiHeader ipiHeader                // Basic Image info
	iciBase16 imageComponentAttributes // Image attributes for the base16 image
	iciBase4  imageComponentAttributes // Image attributes for the base4 image
	iciBase   imageComponentAttributes // Image attributes for the base image
	ici4Base  imageComponentAttributes // Image attributes for the 4base image
	ici16Base imageComponentAttributes // Image attributes for the 16base image
}

const kHuffmanErrorLen byte = 0x1f

func pcd16(d []byte) uint {
	return (uint(d[0]) << 8) | uint(d[1])
}

func pcd32(d []byte) uint {
	return (uint(d[0]) << 24) | (uint(d[1]) << 16) | (uint(d[2]) << 8) | uint(d[3])
}

const sectorSize = 0x800

const (
	SceneBase16 = iota //	128 × 192		0.025 Mpix	0.07 Mb		Preview (index print, thumbnail)
	SceneBase4         //	256 × 384		0.098 Mpix	0.28 Mb		Web
	SceneBase          //	512 × 768		0.393 Mpix	1.13 Mb		Computer screen, TV, Web
	Scene4Base         //	1024 × 1536		1.573 Mpix	4.50 Mb		HDTV screen
	Scene16Base        //	2048 × 3072		6.291 Mpix	18.00 Mb	Print-out up to ca. 20 x 30 cm
	Scene64Base        // 4096 × 6144		25.166 Mpix	72.00 Mb	Professional print, pre-press, archiving (optional)
)

const MaxScene = 6

var pcdLumaWidth = [MaxScene]int{192, 192 << 1, 192 << 2, 192 << 3, 192 << 4, 192 << 5}
var pcdLumaHeight = [MaxScene]int{128, 128 << 1, 128 << 2, 128 << 3, 128 << 4, 128 << 5}
var pcdChromaWidth = [MaxScene]int{96, 96 << 1, 96 << 2, 96 << 2, 96 << 4, 96 << 5}
var pcdChromaHeight = [MaxScene]int{64, 64 << 1, 64 << 2, 64 << 2, 64 << 4, 64 << 5}

type Decoder struct {
	r io.ReadSeeker
}

func NewDecoder(r io.ReadSeeker) *Decoder {
	return &Decoder{r: r}
}

func (d *Decoder) readBaseImage(r io.ReadSeeker, scene int, offset int64) (img *image.YCbCr, err error) {
	if scene < 0 || scene >= Scene64Base {
		err = errors.New("invalid scene")
		return
	}

	_, err = r.Seek(offset, os.SEEK_SET)
	if err != nil {
		return
	}

	cwidth := pcdChromaWidth[scene]
	cheight := pcdChromaHeight[scene]

	yuv := image.NewYCbCr(image.Rect(0, 0, cwidth*2, cheight*2), image.YCbCrSubsampleRatio420)
	for y := 0; y < cheight; y++ {
		_, err = io.ReadFull(r, yuv.Y[y*2*cwidth*2:(y+1)*2*cwidth*2]) // 2 lines
		if err != nil {
			break
		}
		_, err = io.ReadFull(r, yuv.Cb[y*cwidth:(y+1)*cwidth])
		if err != nil {
			break
		}
		_, err = io.ReadFull(r, yuv.Cr[y*cwidth:(y+1)*cwidth])
		if err != nil {
			break
		}
	}

	if err != nil {
		return
	}

	img = yuv
	return
}

func (d *Decoder) Decode() (image.Image, int, error) {
	return d.DecodeImage(Scene16Base)
}

func (d *Decoder) DecodeImage(scene int) (img image.Image, rotate int, err error) {
	var yuv *image.YCbCr
	yuv, rotate, err = d.decodeImage(scene)
	if err != nil {
		return
	}

	img = toRGBA(yuv)
	return
}

func (d *Decoder) decodeImage(scene int) (img *image.YCbCr, rotate int, err error) {
	r := d.r
	data := make([]byte, unsafe.Sizeof(fileHeader{}))
	_, err = io.ReadFull(r, data)
	if err != nil {
		return
	}

	hdr := (*fileHeader)(unsafe.Pointer(&data[0]))
	if !bytes.Equal(hdr.ipiHeader.ipiSignature[:], []byte("PCD_IPI")) {
		err = errors.New("invalid format")
		return
	}

	if hdr.iciBase16.interleaveRatio != 1 {
		err = errors.New("unsupported: audio file")
		return
	}

	rotate = int(hdr.iciBase16.attributes & 0x03)
	//	imageResolution := int((hdr.iciBase16.attributes>>2)&0x03) + int(kBase)
	//	imageIPEAvailable := (hdr.iciBase16.attributes >> 4) & 0x01
	//	imageHuffmanClass := (hdr.iciBase16.attributes >> 5) & 0x02
	base4Stop := pcd16(hdr.iciBase16.sectorStop4Base[:])

	var ICDOffset = [MaxScene]uint{4, 23, 96, 389, 0, 0}
	var HCTOffset = [MaxScene]uint{0, 0, 0, 388, 0, 0}
	ICDOffset[Scene16Base] = base4Stop + 14
	HCTOffset[Scene16Base] = base4Stop + 12

	current := scene
	if current > SceneBase {
		current = SceneBase
	}

	for ; current >= 0; current-- {
		img, err = d.readBaseImage(r, current, int64(ICDOffset[current])*sectorSize)
		if err == nil {
			break
		}
	}

	if scene <= int(SceneBase) || err != nil {
		return
	}

	// Base not found for higher resolution
	if current < int(SceneBase) {
		return
	}

	// 4Base
	_, err = r.Seek(int64(sectorSize*HCTOffset[Scene4Base]), os.SEEK_SET)
	if err != nil {
		return
	}

	ht, err := d.readHuffTables(1)
	if err != nil {
		return
	}

	_, err = r.Seek(int64(sectorSize*ICDOffset[Scene4Base]), os.SEEK_SET)
	if err != nil {
		return
	}

	rb := newHuffBuffer(r, ht)
	deltas := [][]int8{
		make([]int8, pcdLumaWidth[Scene4Base]*pcdLumaHeight[Scene4Base]),
	}

	err = rb.readDeltas(deltas, pcdLumaHeight[Scene4Base], []int{pcdLumaWidth[Scene4Base]})
	if err != nil {
		return
	}

	img, err = d.upscaleImage(img, deltas)
	if err != nil || scene == int(Scene4Base) {
		return
	}

	// 16Base
	_, err = r.Seek(int64(sectorSize*HCTOffset[Scene16Base]), os.SEEK_SET)
	if err != nil {
		return
	}

	ht, err = d.readHuffTables(3)
	if err != nil {
		return
	}

	_, err = r.Seek(int64(sectorSize*ICDOffset[Scene16Base]), os.SEEK_SET)
	if err != nil {
		return
	}

	rb = newHuffBuffer(r, ht)
	deltas = [][]int8{
		make([]int8, pcdLumaWidth[Scene16Base]*pcdLumaHeight[Scene16Base]),
		make([]int8, pcdChromaWidth[Scene16Base]*pcdChromaHeight[Scene16Base]),
		make([]int8, pcdChromaWidth[Scene16Base]*pcdChromaHeight[Scene16Base]),
	}
	err = rb.readDeltas(deltas, pcdLumaHeight[Scene16Base]+2*pcdChromaHeight[Scene16Base], []int{pcdLumaWidth[Scene16Base], pcdChromaWidth[Scene16Base], pcdChromaWidth[Scene16Base]})
	if err != nil {
		return
	}

	img, err = d.upscaleImage(img, deltas)
	return
}

func upscale(width, height int, base []byte, up []byte) {
	for i := 0; i < height; i++ {
		for j := 0; j < width; j++ {
			i1, j1 := i+1, j+1
			if i1 >= height {
				i1 = height - 1
			}
			if j1 >= width {
				j1 = width - 1
			}

			b00 := int(base[i*width+j])
			b01 := int(base[i*width+j1])
			b10 := int(base[i1*width+j])
			b11 := int(base[i1*width+j1])

			up[i*2*width*2+j*2] = byte(b00)
			up[i*2*width*2+j*2+1] = byte((b00 + b01 + 1) >> 1)
			up[(i*2+1)*width*2+j*2] = byte((b00 + b10 + 1) >> 1)
			up[(i*2+1)*width*2+j*2+1] = byte((b00 + b01 + b10 + b11 + 2) >> 2)
		}
	}
}

func addTo(x []byte, delta []int8) {
	for i, b := range x {
		n := int(b) + int(delta[i])
		if n < 0 {
			n = 0
		} else if n > 255 {
			n = 255
		}
		x[i] = byte(n)
	}
}

func (d *Decoder) upscaleImage(img *image.YCbCr, deltas [][]int8) (*image.YCbCr, error) {
	width, height := img.Bounds().Dx(), img.Bounds().Dy()
	nimg := image.NewYCbCr(image.Rect(0, 0, width*2, height*2), image.YCbCrSubsampleRatio420)

	upscale(width, height, img.Y, nimg.Y)
	upscale(width/2, height/2, img.Cb, nimg.Cb)
	upscale(width/2, height/2, img.Cr, nimg.Cr)

	addTo(nimg.Y, deltas[0])
	if len(deltas) == 3 {
		addTo(nimg.Cb, deltas[1])
		addTo(nimg.Cr, deltas[2])
	}

	return nimg, nil
}

type huffTable struct {
	key [0x10000]byte
	len [0x10000]byte
}

func newHuffTable() *huffTable {
	t := &huffTable{}
	for i := 0; i < 0x10000; i++ {
		t.key[i] = 0x7f
		t.len[i] = kHuffmanErrorLen
	}
	return t
}

func (d *Decoder) readHuffTables(numTables int) (tables []*huffTable, err error) {
	n := 1
	if numTables == 3 {
		n = 2
	}

	buf := make([]byte, sectorSize*n)
	_, err = io.ReadFull(d.r, buf)
	if err != nil {
		return tables, err
	}

	tables = make([]*huffTable, numTables)
	for i := 0; i < numTables; i++ {
		t := newHuffTable()
		entries := int(buf[0]) // entries + (4+1) * entries
		pbuf := buf[1:]
		for j := 0; j < entries; j++ {
			length, codeword, key := int(pbuf[0])+1, pbuf[1:3], pbuf[3] // 4 bytes per entry
			if length > 16 {
				log.Printf("%d %d %d %v %v %v\n", i, j, entries, length, codeword, key)
				err = errors.New("invalid length")
				return
			}

			for index := 0; index < (0x1 << (16 - length)); index++ {
				loc := int(pcd16(codeword)) | index
				t.key[loc] = key
				t.len[loc] = byte(length)
			}
			pbuf = pbuf[4:]
		}

		tables[i] = t
		if entries < 4 && i > 0 { //use previous table?
			tables[i] = tables[i-1]
		}

		buf = buf[(entries+1)*4+1:] //move to next table
	}

	return
}

type huffBuffer struct {
	r io.Reader
	t []*huffTable

	buf  [sectorSize]byte
	sum  uint
	bits uint
	pos  int
}

func newHuffBuffer(r io.Reader, t []*huffTable) *huffBuffer {
	b := &huffBuffer{r: r, t: t}
	b.pos = sectorSize // trigger to read first sector
	b.getBits(0)
	return b
}

func (b *huffBuffer) getBits(n uint) error {
	b.sum = (b.sum << n) & 0xffffffff
	b.bits -= n
	for b.bits <= 24 {
		if b.pos >= sectorSize {
			_, err := io.ReadFull(b.r, b.buf[:])
			if err != nil {
				return err
			}
			b.pos = 0
		}
		b.sum |= uint(b.buf[b.pos]) << (24 - b.bits)
		b.bits += 8
		b.pos++
	}

	return nil
}

func (b *huffBuffer) sync() error {
	var skipped bool
	for !((b.sum & 0x00fff000) == 0x00fff000) {
		if err := b.getBits(8); err != nil {
			return err
		}
		skipped = true
	}
	for !((b.sum & 0xffffff00) == 0xfffffe00) {
		if err := b.getBits(1); err != nil {
			return err
		}
		skipped = true
	}

	if skipped {
		log.Printf("sync skipped\n")
	}

	return nil
}

func (b *huffBuffer) decode(buf []int8, ht *huffTable) error {
	for i := 0; i < len(buf); i++ {
		code := (b.sum >> 16) & 0xffff
		len := ht.len[code]
		if len == kHuffmanErrorLen {
			log.Printf("invalid code\n")

			b.sync() // skip to next
			return errors.New("invalid code sequence")
		}
		buf[i] = int8(ht.key[code])
		b.getBits(uint(len))
	}

	return nil
}

func (b *huffBuffer) readDeltas(buf [][]int8, total int, widths []int) (err error) {
	count := 0
	for {
		if count >= total {
			break
		}

		b.sync()

		// Get the first 24 bits into the shift register - these have the plane, row and sequence numbers
		b.getBits(16)
		row := int((b.sum >> 9) & 0x1fff)
		row2 := row >> 1
		// sequence := 0
		plane := (b.sum >> 22) & 0x03

		// skip 3 bytes
		b.getBits(8 * 3)

		switch plane {
		case 0:
			err = b.decode(buf[0][row*widths[0]:(row+1)*widths[0]], b.t[0])
			if err != nil {
				return
			}
		case 2:
			err = b.decode(buf[1][row2*widths[1]:(row2+1)*widths[1]], b.t[1])
			if err != nil {
				return
			}
		case 3:
			err = b.decode(buf[2][row2*widths[2]:(row2+1)*widths[2]], b.t[2])
			if err != nil {
				return
			}
		}

		count++
	}

	return nil
}

func clamp(x, min, max int) int {
	if x < min {
		return min
	}
	if x > max {
		return max
	}
	return x
}

func toRGBA(img *image.YCbCr) *image.RGBA {
	r := img.Bounds()
	w, h := r.Dx(), r.Dy()
	out := image.NewRGBA(r)
	for y := 0; y < h; y++ {
		for x := 0; x < w; x++ {
			li := y*w + x
			ci := (y>>1)*(w>>1) + (x >> 1)
			l := int(img.Y[li]) * 5573
			c1 := (int(img.Cb[ci]) - 156) * 9085
			c2 := (int(img.Cr[ci]) - 137) * 7461
			ri := clamp((l+c2)>>10, 0, 1388)
			gi := clamp((l>>10)-c1/5278-c2/2012, 0, 1388)
			bi := clamp((l+c1)>>10, 0, 1388)

			out.SetRGBA(x, y, color.RGBA{R: rgbTab[ri], G: rgbTab[gi], B: rgbTab[bi], A: 0xff})
		}
	}

	return out
}

var rgbTab = [1389]byte{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x03, 0x03, 0x03, 0x03, 0x03, 0x04, 0x04,
	0x04, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06,
	0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x08, 0x08, 0x08, 0x08,
	0x08, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0d,
	0x0d, 0x0d, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0e, 0x0e, 0x0e, 0x0f, 0x0f,
	0x0f, 0x0f, 0x0f, 0x0f, 0x10, 0x10, 0x10, 0x10, 0x10, 0x11, 0x11, 0x11,
	0x11, 0x11, 0x12, 0x12, 0x12, 0x12, 0x12, 0x12, 0x13, 0x13, 0x13, 0x13,
	0x13, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x15, 0x15, 0x15, 0x15, 0x15,
	0x16, 0x16, 0x16, 0x16, 0x16, 0x16, 0x17, 0x17, 0x17, 0x17, 0x17, 0x18,
	0x18, 0x18, 0x18, 0x18, 0x18, 0x19, 0x19, 0x19, 0x19, 0x19, 0x1a, 0x1a,
	0x1a, 0x1a, 0x1a, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1b, 0x1c, 0x1c, 0x1c,
	0x1c, 0x1c, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1d, 0x1e, 0x1e, 0x1e, 0x1e,
	0x1e, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x1f, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x21, 0x21, 0x21, 0x21, 0x21, 0x21, 0x22, 0x22, 0x22, 0x22, 0x22, 0x23,
	0x23, 0x23, 0x23, 0x23, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x25, 0x25,
	0x25, 0x25, 0x25, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x27, 0x27, 0x27,
	0x27, 0x27, 0x28, 0x28, 0x28, 0x28, 0x28, 0x28, 0x29, 0x29, 0x29, 0x29,
	0x29, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2b, 0x2b, 0x2b, 0x2b, 0x2b,
	0x2c, 0x2c, 0x2c, 0x2c, 0x2c, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2d, 0x2e,
	0x2e, 0x2e, 0x2e, 0x2e, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x2f, 0x30, 0x30,
	0x30, 0x30, 0x30, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x32, 0x32, 0x32,
	0x32, 0x32, 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x34, 0x34, 0x34, 0x34,
	0x34, 0x35, 0x35, 0x35, 0x35, 0x35, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
	0x37, 0x37, 0x37, 0x37, 0x37, 0x38, 0x38, 0x38, 0x38, 0x38, 0x38, 0x39,
	0x39, 0x39, 0x39, 0x39, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3a, 0x3b, 0x3b,
	0x3b, 0x3b, 0x3b, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3c, 0x3d, 0x3d, 0x3d,
	0x3d, 0x3d, 0x3e, 0x3e, 0x3e, 0x3e, 0x3e, 0x3f, 0x3f, 0x3f, 0x3f, 0x3f,
	0x3f, 0x40, 0x40, 0x40, 0x40, 0x40, 0x41, 0x41, 0x41, 0x41, 0x41, 0x41,
	0x42, 0x42, 0x42, 0x42, 0x42, 0x43, 0x43, 0x43, 0x43, 0x43, 0x43, 0x44,
	0x44, 0x44, 0x44, 0x44, 0x45, 0x45, 0x45, 0x45, 0x45, 0x45, 0x46, 0x46,
	0x46, 0x46, 0x46, 0x47, 0x47, 0x47, 0x47, 0x47, 0x48, 0x48, 0x48, 0x48,
	0x48, 0x48, 0x49, 0x49, 0x49, 0x49, 0x49, 0x4a, 0x4a, 0x4a, 0x4a, 0x4a,
	0x4a, 0x4b, 0x4b, 0x4b, 0x4b, 0x4b, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c,
	0x4d, 0x4d, 0x4d, 0x4d, 0x4d, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4f,
	0x4f, 0x4f, 0x4f, 0x4f, 0x50, 0x50, 0x50, 0x50, 0x50, 0x51, 0x51, 0x51,
	0x51, 0x51, 0x51, 0x52, 0x52, 0x52, 0x52, 0x52, 0x53, 0x53, 0x53, 0x53,
	0x53, 0x53, 0x54, 0x54, 0x54, 0x54, 0x54, 0x55, 0x55, 0x55, 0x55, 0x55,
	0x55, 0x56, 0x56, 0x56, 0x56, 0x56, 0x57, 0x57, 0x57, 0x57, 0x57, 0x58,
	0x58, 0x58, 0x58, 0x58, 0x58, 0x59, 0x59, 0x59, 0x59, 0x59, 0x5a, 0x5a,
	0x5a, 0x5a, 0x5a, 0x5a, 0x5b, 0x5b, 0x5b, 0x5b, 0x5b, 0x5c, 0x5c, 0x5c,
	0x5c, 0x5c, 0x5c, 0x5d, 0x5d, 0x5d, 0x5d, 0x5d, 0x5e, 0x5e, 0x5e, 0x5e,
	0x5e, 0x5e, 0x5f, 0x5f, 0x5f, 0x5f, 0x5f, 0x60, 0x60, 0x60, 0x60, 0x60,
	0x61, 0x61, 0x61, 0x61, 0x61, 0x61, 0x62, 0x62, 0x62, 0x62, 0x62, 0x63,
	0x63, 0x63, 0x63, 0x63, 0x63, 0x64, 0x64, 0x64, 0x64, 0x64, 0x65, 0x65,
	0x65, 0x65, 0x65, 0x65, 0x66, 0x66, 0x66, 0x66, 0x66, 0x67, 0x67, 0x67,
	0x67, 0x67, 0x67, 0x68, 0x68, 0x68, 0x68, 0x68, 0x69, 0x69, 0x69, 0x69,
	0x69, 0x6a, 0x6a, 0x6a, 0x6a, 0x6a, 0x6a, 0x6b, 0x6b, 0x6b, 0x6b, 0x6b,
	0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6c, 0x6d, 0x6d, 0x6d, 0x6d, 0x6d, 0x6e,
	0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6f, 0x6f, 0x6f, 0x6f, 0x6f, 0x70, 0x70,
	0x70, 0x70, 0x70, 0x70, 0x71, 0x71, 0x71, 0x71, 0x71, 0x72, 0x72, 0x72,
	0x72, 0x72, 0x73, 0x73, 0x73, 0x73, 0x73, 0x73, 0x74, 0x74, 0x74, 0x74,
	0x74, 0x75, 0x75, 0x75, 0x75, 0x75, 0x75, 0x76, 0x76, 0x76, 0x76, 0x76,
	0x77, 0x77, 0x77, 0x77, 0x77, 0x77, 0x78, 0x78, 0x78, 0x78, 0x78, 0x79,
	0x79, 0x79, 0x79, 0x79, 0x79, 0x7a, 0x7a, 0x7a, 0x7a, 0x7a, 0x7b, 0x7b,
	0x7b, 0x7b, 0x7b, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7c, 0x7d, 0x7d, 0x7d,
	0x7d, 0x7d, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7e, 0x7f, 0x7f, 0x7f, 0x7f,
	0x7f, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x81, 0x81, 0x81, 0x81, 0x81,
	0x82, 0x82, 0x82, 0x82, 0x82, 0x82, 0x83, 0x83, 0x83, 0x83, 0x83, 0x84,
	0x84, 0x84, 0x84, 0x84, 0x85, 0x85, 0x85, 0x85, 0x85, 0x85, 0x86, 0x86,
	0x86, 0x86, 0x86, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x88, 0x88, 0x88,
	0x88, 0x88, 0x89, 0x89, 0x89, 0x89, 0x89, 0x89, 0x8a, 0x8a, 0x8a, 0x8a,
	0x8a, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8b, 0x8c, 0x8c, 0x8c, 0x8c, 0x8c,
	0x8d, 0x8d, 0x8d, 0x8d, 0x8d, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8e, 0x8f,
	0x8f, 0x8f, 0x8f, 0x8f, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0x91, 0x91,
	0x91, 0x91, 0x91, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x93, 0x93, 0x93,
	0x93, 0x93, 0x94, 0x94, 0x94, 0x94, 0x94, 0x94, 0x95, 0x95, 0x95, 0x95,
	0x95, 0x96, 0x96, 0x96, 0x96, 0x96, 0x97, 0x97, 0x97, 0x97, 0x97, 0x97,
	0x98, 0x98, 0x98, 0x98, 0x98, 0x99, 0x99, 0x99, 0x99, 0x99, 0x99, 0x9a,
	0x9a, 0x9a, 0x9a, 0x9a, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9b, 0x9c, 0x9c,
	0x9c, 0x9c, 0x9c, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9d, 0x9e, 0x9e, 0x9e,
	0x9e, 0x9e, 0x9f, 0x9f, 0x9f, 0x9f, 0x9f, 0xa0, 0xa0, 0xa0, 0xa0, 0xa0,
	0xa0, 0xa1, 0xa1, 0xa1, 0xa1, 0xa1, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2, 0xa2,
	0xa3, 0xa3, 0xa3, 0xa3, 0xa3, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa4, 0xa5,
	0xa5, 0xa5, 0xa5, 0xa5, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa6, 0xa7, 0xa7,
	0xa7, 0xa7, 0xa7, 0xa8, 0xa8, 0xa8, 0xa8, 0xa8, 0xa9, 0xa9, 0xa9, 0xa9,
	0xa9, 0xa9, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xab, 0xab, 0xab, 0xab, 0xab,
	0xab, 0xac, 0xac, 0xac, 0xac, 0xac, 0xad, 0xad, 0xad, 0xad, 0xad, 0xad,
	0xae, 0xae, 0xae, 0xae, 0xae, 0xaf, 0xaf, 0xaf, 0xaf, 0xaf, 0xb0, 0xb0,
	0xb0, 0xb0, 0xb0, 0xb0, 0xb1, 0xb1, 0xb1, 0xb1, 0xb1, 0xb2, 0xb2, 0xb2,
	0xb2, 0xb2, 0xb2, 0xb3, 0xb3, 0xb3, 0xb3, 0xb3, 0xb4, 0xb4, 0xb4, 0xb4,
	0xb4, 0xb4, 0xb5, 0xb5, 0xb5, 0xb5, 0xb5, 0xb6, 0xb6, 0xb6, 0xb6, 0xb6,
	0xb6, 0xb7, 0xb7, 0xb7, 0xb7, 0xb7, 0xb8, 0xb8, 0xb8, 0xb8, 0xb8, 0xb9,
	0xb9, 0xb9, 0xb9, 0xb9, 0xb9, 0xba, 0xba, 0xba, 0xba, 0xba, 0xbb, 0xbb,
	0xbb, 0xbb, 0xbb, 0xbb, 0xbc, 0xbc, 0xbc, 0xbc, 0xbc, 0xbd, 0xbd, 0xbd,
	0xbd, 0xbd, 0xbd, 0xbe, 0xbe, 0xbe, 0xbe, 0xbe, 0xbf, 0xbf, 0xbf, 0xbf,
	0xbf, 0xbf, 0xc0, 0xc0, 0xc0, 0xc0, 0xc0, 0xc1, 0xc1, 0xc1, 0xc1, 0xc1,
	0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc2, 0xc3, 0xc3, 0xc3, 0xc3, 0xc3, 0xc4,
	0xc4, 0xc4, 0xc4, 0xc4, 0xc4, 0xc5, 0xc5, 0xc5, 0xc5, 0xc5, 0xc6, 0xc6,
	0xc6, 0xc6, 0xc6, 0xc6, 0xc7, 0xc7, 0xc7, 0xc7, 0xc7, 0xc8, 0xc8, 0xc8,
	0xc8, 0xc8, 0xc8, 0xc9, 0xc9, 0xc9, 0xc9, 0xc9, 0xca, 0xca, 0xca, 0xca,
	0xca, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcb, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc,
	0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xcd, 0xce, 0xce, 0xce, 0xce, 0xce, 0xcf,
	0xcf, 0xcf, 0xcf, 0xcf, 0xcf, 0xd0, 0xd0, 0xd0, 0xd0, 0xd0, 0xd1, 0xd1,
	0xd1, 0xd1, 0xd1, 0xd1, 0xd2, 0xd2, 0xd2, 0xd2, 0xd2, 0xd3, 0xd3, 0xd3,
	0xd3, 0xd3, 0xd4, 0xd4, 0xd4, 0xd4, 0xd4, 0xd4, 0xd5, 0xd5, 0xd5, 0xd5,
	0xd5, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd6, 0xd7, 0xd7, 0xd7, 0xd7, 0xd7,
	0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd8, 0xd9, 0xd9, 0xd9, 0xd9, 0xd9, 0xda,
	0xda, 0xda, 0xda, 0xda, 0xda, 0xdb, 0xdb, 0xdb, 0xdb, 0xdb, 0xdc, 0xdc,
	0xdc, 0xdc, 0xdc, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0xde, 0xde, 0xde,
	0xde, 0xde, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xdf, 0xe0, 0xe0, 0xe0, 0xe0,
	0xe0, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe1, 0xe2, 0xe2, 0xe2, 0xe2, 0xe2,
	0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0xe3, 0xe4, 0xe4, 0xe4, 0xe4, 0xe4, 0xe5,
	0xe5, 0xe5, 0xe5, 0xe5, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe6, 0xe7, 0xe7,
	0xe7, 0xe7, 0xe7, 0xe8, 0xe8, 0xe8, 0xe8, 0xe8, 0xe8, 0xe9, 0xe9, 0xe9,
	0xe9, 0xe9, 0xea, 0xea, 0xea, 0xea, 0xea, 0xea, 0xeb, 0xeb, 0xeb, 0xeb,
	0xeb, 0xec, 0xec, 0xec, 0xec, 0xec, 0xec, 0xed, 0xed, 0xed, 0xed, 0xed,
	0xee, 0xee, 0xee, 0xee, 0xee, 0xef, 0xef, 0xef, 0xef, 0xef, 0xef, 0xf0,
	0xf0, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf2, 0xf2,
	0xf2, 0xf2, 0xf2, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf3, 0xf4, 0xf4, 0xf4,
	0xf4, 0xf4, 0xf5, 0xf5, 0xf5, 0xf5, 0xf5, 0xf5, 0xf6, 0xf6, 0xf6, 0xf6,
	0xf6, 0xf7, 0xf7, 0xf7, 0xf7, 0xf7, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8,
	0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfa, 0xfb,
	0xfb, 0xfb, 0xfb, 0xfb, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfc, 0xfd, 0xfd,
	0xfd, 0xfd, 0xfd, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xff,
}
